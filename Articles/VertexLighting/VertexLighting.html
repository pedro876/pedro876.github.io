<h1>Baked Vertex Lighting</h1>
<h2>
    April 8th, 2025 <br />
    Unreleased Project
</h2>

<h3>Motivation</h3>

<p>
  Recently I covered the topic of baking ambient occlusion on a per-vertex basis. Once the team saw the results combined with realtime lights it was clear that we were getting closer to the desired art style, which should be reminiscent of 3DS titles like <i>The Legend Of Zelda: Majora's Mask</i>.
</p>

<p>
  However, we soon realized how limited those realtime per-vertex lights are in Unity:
</p>

<ul>
  <li>
    <b>Limited lights per object</b>: Only up to eight lights can be applied per object, which means that manual mesh slicing would have to be applied if more are required.
  </li>
  <li>
    <b>No shadows</b>: Shadow maps are not supported for vertex lighting. This makes it very hard to convincingly illuminate environments and provokes major leaking issues.
  </li>
</ul>

<p>
  Taking into account that most of those lights will be static and having implemented baked per-vertex AO just recently, the solution was clear: Baked per-vertex lighting.
</p>

<p style="color:red">Imagen de portada</p>

<h3>Implementation</h3>

<p>The new code for light baking will be added to the existing ambient occlusion implementation, so occlusion and lighting act as the same system. Requirements:</p>

<ol>
  <li>
    <b>Infinite static lights</b>.
  </li>
  <li>
    <b>Different light types</b>: Directional, point and spot lights.
  </li>
  <li>
    <b>Configurable lights</b>: Range, intensity, color, shadow strength, angle attenuation, etc.
  </li>
  <li>
    <b>Indirect lighting</b>.
  </li>
  <li>
    <b>Realtime fallback</b>: A static light creates a realtime counterpart that only affects dynamic objects.
  </li>
  <li>
    <b>Two baking sets</b>: In the game there are two possible lighting scenarios, and it must be possible to blend between them in realtime.
  </li>
  <li>
    <b>High performance</b>: Baking a complex model with several lights should be very fast to allow fluid iterations of light configurations. Ideally under five seconds.
  </li>
</ol>

<h3>Performance</h3>

<p>
  Once the algorithm was complete and we tested it on complex models, it terribly underperformed in terms of speed. What had to be executed in less than five seconds, took over three minutes.
</p>

<p>
  If we didn't address this issue, baking would be a pain during the entire development process. Not only that, but it would disincentivize the use of baked lights, reducing the overall quality of the presentation.
</p>

<p>
  Fortunately, this algorithm is highly parallelizable, so I created a compute shader and mirrored the entire algorithm. In the CPU implementation, Unity's collider components are used to raycast occlusion, shadows, and indirect lighting. Implementing that in the compute shader would be possible, but it would take a considerable amount of effort. Thankfully, raytracing shaders exist so I didn't have to implement mesh raycasting myself.
</p>

<p>
  Using raytracing and compute shaders improves performance dramatically. It takes literally less than a second to bake an entire environment now, with all the features enabled. Now, artists can iterate on lighting blazingly fast. To make it even quicker, I added a keyboard shortcut to preview results that doesn't save the results persistenly and only bakes the current lighting scenario.
</p>



<h3>Results</h3>

<h3>Conclusion</h3>

<h3>Going forward</h3>