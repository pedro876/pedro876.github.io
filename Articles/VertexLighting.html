<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Baked Vertex Lighting</title>
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    <link rel="stylesheet" href="/main.css" />
</head>
<body>
    <main>
        <h1>Baked Vertex Lighting</h1>
        <h2>
            April 8th, 2025 <br />
            Unreleased Project
        </h2>

        <h3>Motivation</h3>

        <p>
            Recently I covered the topic of baking ambient occlusion on a per-vertex basis. Once the team saw the results combined
            with realtime lights it was clear that we were getting closer to the desired art style, which should be reminiscent of
            3DS titles like <i>The Legend Of Zelda: Majora's Mask</i>.
        </p>

        <p>
            However, we soon realized how limited those realtime per-vertex lights are in Unity:
        </p>

        <ul>
            <li>
                <b>Limited lights per object</b>: Only up to eight lights can be applied per object, which means that manual
                mesh slicing would have to be applied if more are required.
            </li>
            <li>
                <b>No shadows</b>: Shadow maps are not supported for vertex lighting. This makes it very hard to convincingly
                illuminate environments and provokes major leaking issues.
            </li>
        </ul>

        <p>
            Taking into account that most of those lights will be static and having implemented baked per-vertex AO just recently,
            the solution was clear: Baked per-vertex lighting.
        </p>

        <figure data-image='{"maximizable": true}'>
            <img src="VertexLighting/Images/VertexLighting_MilkBar_LitIndirect_0.png" />
            <figcaption>Milk Bar Lit Indirect</figcaption>
        </figure>

        <!--<div data-image='{
        "images": ["Articles/VertexLighting/Images/VertexLighting_MilkBar_LitIndirect_0.png"]
        , "maximizable": true
    }'></div>-->

        <h3>Implementation</h3>

        <p>
            The new code for light baking will be added to the existing ambient occlusion implementation, so occlusion and
            lighting act as the same system. Requirements:
        </p>

        <ol>
            <li>
                <b>Infinite static lights</b>.
            </li>
            <li>
                <b>Different light types</b>: Directional, point and spot lights.
            </li>
            <li>
                <b>Configurable lights</b>: Range, intensity, color, shadow strength, angle attenuation, etc.
            </li>
            <li>
                <b>Indirect lighting</b>: Each light must have the ability to bounce its rays across the environment to attain more realistic lighting.
            </li>
            <li>
                <b>Realtime fallback</b>: A static light creates a realtime counterpart that only affects dynamic objects.
            </li>
            <li>
                <b>Two baking sets</b>: In the game there are two possible lighting scenarios, and it must be possible to blend between them in realtime.
            </li>
            <li>
                <b>High performance</b>: Baking a complex model with several lights should be very fast to reduce iteration times of
                light configurations. Ideally under five seconds.
            </li>
        </ol>

        <h4>Light types</h4>

        <p>
            Lights are defined using a custom component, and the baking system iterates these lights to add up their contributions to
            each vertex. There are three light types:
        </p>

        <ul>
            <li>
                <b>Directional</b>: Does not attenuate over distance and the light direction is always the same because it doesn't have a position.
            </li>
            <li>
                <b>Point</b>: Attenuates over distance, reaching zero energy at a defined range. The direction varies because the light has a defined position.
            </li>
            <li>
                <b>Spot</b>: It's the same as the point light, but additionally attenuates as the angle between the light's
                forward direction and the direction from the vertex to the light's position grows.
            </li>
        </ul>

        <figure data-image='{"maximizable": true}'>
            <img src="VertexLighting/Images/VertexLighting_Type_Directional.png" alt="Directional" />
            <figcaption>Vertex Directional Light</figcaption>
        </figure>

        <!--<div data-image='{
        "images": ["Articles/VertexLighting/Images/VertexLighting_Type_Directional.png"]
        , "texts": ["Directional"]
        , "maximizable": true
    }'></div>-->

        <figure data-image='{"maximizable": true}'>
            <img src="VertexLighting/Images/VertexLighting_Type_Point.png" alt="Point" />
            <figcaption>Vertex Point Light</figcaption>
        </figure>

        <!--<div data-image='{
        "images": ["Articles/VertexLighting/Images/VertexLighting_Type_Point.png"]
        , "texts": ["Point"]
        , "maximizable": true
    }'></div>-->

        <figure data-image='{"maximizable": true}'>
            <img src="VertexLighting/Images/VertexLighting_Type_Spot.png" alt="Spot" />
            <figcaption>Vertex Spot Light</figcaption>
        </figure>

        <!--<div data-image='{
        "images": ["Articles/VertexLighting/Images/VertexLighting_Type_Spot.png"]
        , "texts": ["Spot"]
        , "maximizable": true
    }'></div>-->

        <pre><code data-lang="hlsl">
        #define LIGHTTYPE_DIRECTIONAL 0
        #define LIGHTTYPE_POINT 1
        #define LIGHTTYPE_SPOT 2

        struct Light
        {
            int type;
            float3 position;
            float3 direction;
            int castShadows;
            int allowBouncing;
            float3 color;
            float intensity;
            float indirectIntensity;
            float range;
            float2 spotAngle;
            float angleStrength;
            float shadowStrength;
        };

        StructuredBuffer<Light> _Lights;
        int _LightCount;

        float GetLightAttenuation(float3 positionWS, float3 normalWS, int lightType, 
            Light light, float3 lightPosition, float3 lightDirection)
        {
            float distanceAtten = 1.0;
            if (lightType != LIGHTTYPE_DIRECTIONAL)
            {
                float3 dir = positionWS - light.position;
                float distanceSqr = SqrMagnitude(dir);
                distanceAtten = 1.0 - pow(distanceSqr / (light.range * light.range), 2.0);
                distanceAtten = max(0.0, distanceAtten);
                distanceAtten *= distanceAtten;
            }

            float angleAttenuation = saturate(dot(normalWS, lightDirection));
            angleAttenuation = lerp(1.0, angleAttenuation, light.angleStrength);


            if (lightType == LIGHTTYPE_SPOT)
            {
                float outerAngle = light.spotAngle.y;
                float innerAngle = light.spotAngle.x;
                float cosOuter = cos(DEG2RAD * outerAngle * 0.5);
                float cosInner = cos(DEG2RAD * innerAngle * 0.5);
                float angle = dot(normalize(positionWS - lightPosition), light.direction);
                float spotAtten = saturate((angle - cosOuter) / (cosInner - cosOuter));
                spotAtten *= spotAtten;
                angleAttenuation *= spotAtten;
            }

            return angleAttenuation * distanceAtten;
        }
        </code></pre>

        <!--<div class="code" data-lang="hlsl" data-url="Articles/VertexLighting/LightTypes.hlsl"></div>-->

        <h4>Shadows</h4>

        <p>
            In order to calculate shadows, the intuitive approach is to simply raycast from the vertex to the light and it's contribution
            only if the raycast fails. However, this results in binary shadows that look blocky and unappealing.
            Similar to how PCF shadows work, it's better to define a set of points in an circular area around the vertex, raycast from
            each of them and average the results.
        </p>

        <figure data-image='{"sliderValue":50, "maximizable": true}'>
            <img src="VertexLighting/Images/VertexLighting_PCF_Off.png" alt="Single Ray" />
            <img src="VertexLighting/Images/VertexLighting_PCF_On.png" alt="Multiple Rays" />
            <figcaption>Single ray vs Multiple rays</figcaption>
        </figure>

        <!--<div data-image='{
        "images": ["Articles/VertexLighting/Images/VertexLighting_PCF_Off.png", "Articles/VertexLighting/Images/VertexLighting_PCF_On.png"]
        , "texts": ["Single ray", "Multiple rays"]
        , "sliderValue": 50
        , "maximizable": true
    }'></div>-->

        <h4>Denoising</h4>

        <p>
            Even after calculating shadows smoothly using multiple rays, results are still a bit blocky and noisy. To address this, the
            results of nearby vertices are merged. This was already implemented for occlusion values but the logic changes when it comes to
            lighting. Instead of merging vertices that are almost exactly at the same position in world space, we increase that distance
            threshold to a meter or more and add a new restriction: vertices must be connected by edges in order to be merged. This prevents
            lighting to leak between different surfaces. Try using the slider in the following images to see the difference:
        </p>

        <figure data-image='{"sliderValue":50, "maximizable": true}'>
            <img src="VertexLighting/Images/VertexLighting_PCF_On.png" alt="Denoise Off" />
            <img src="VertexLighting/Images/VertexLighting_Denoise.png" alt="Denoise On" />
            <figcaption>Denoise Off vs On</figcaption>
        </figure>

        <!--<div data-image='{
        "images": ["Articles/VertexLighting/Images/VertexLighting_PCF_On.png", "Articles/VertexLighting/Images/VertexLighting_Denoise.png"]
        , "texts": ["Denoise Off", "Denoise On"]
        , "sliderValue": 50
        , "maximizable": true
    }'></div>-->

        <figure data-image='{"sliderValue":50, "maximizable": true}'>
            <img src="VertexLighting/Images/VertexLighting_Denoise_Off.png" alt="Denoise Off" />
            <img src="VertexLighting/Images/VertexLighting_Denoise_On.png" alt="Denoise On" />
            <figcaption>Denoise Off vs On</figcaption>
        </figure>

        <!--<div data-image='{
        "images": ["Articles/VertexLighting/Images/VertexLighting_Denoise_Off.png", "Articles/VertexLighting/Images/VertexLighting_Denoise_On.png"]
        , "texts": ["Denoise Off", "Denoise On"]
        , "sliderValue": 50
        , "maximizable": true
    }'></div>-->

        <h4>Indirect Lighting</h4>

        <p>
            Indirect lighting is a more involved process, but rather easy to understand if one's familiar to ambient occlusion. As in the
            later technique, several rays are traced in the normal-aligned hemisphere of the vertex. For those that collide against
            geometry, it is checked if light reaches them and how much is reflected in the ray's direction. This value is averaged across
            the hemisphere and added to the total contribution of that one light.
        </p>

        <p>
            In practice, indirect lighting requires many raycasts to reduce noise and it's yet unclear if it will be used in the game, but's
            it's a nice feature to have in case we end up needing it in the future.
        </p>

        <figure data-image='{"sliderValue":60, "maximizable": true}'>
            <img src="VertexLighting/Images/VertexLighting_Indirect_Off.png" alt="Indirect Off" />
            <img src="VertexLighting/Images/VertexLighting_Indirect_On.png" alt="Indirect On" />
            <figcaption>Indirect Off vs On</figcaption>
        </figure>

        <!--<div data-image='{
        "images": ["Articles/VertexLighting/Images/VertexLighting_Indirect_Off.png", "Articles/VertexLighting/Images/VertexLighting_Indirect_On.png"]
        , "texts": ["Indirect Off", "Indirect On"]
        , "sliderValue": 60
        , "maximizable": true
    }'></div>-->

        <p>
            In actual game environments, especially indoor scenes, the difference can be quite substantial:
        </p>

        <figure data-image='{"sliderValue":50, "maximizable": true}'>
            <img src="VertexLighting/Images/VertexLighting_MilkBar_Lit_0.png" alt="Indirect Off" />
            <img src="VertexLighting/Images/VertexLighting_MilkBar_LitIndirect_0.png" alt="Indirect On" />
            <figcaption>Indirect Off vs On</figcaption>
        </figure>

        <!--<div data-image='{
        "images": ["Articles/VertexLighting/Images/VertexLighting_MilkBar_Lit_0.png", "Articles/VertexLighting/Images/VertexLighting_MilkBar_LitIndirect_0.png"]
        , "texts": ["Indirect Off", "Indirect On"]
        , "sliderValue": 50
        , "maximizable": true
    }'></div>-->

        <h4>Storing vertex data</h4>

        <p>
            Previously, a single occlusion value was stored per vertex in the x coordinate of the fourth texture coordinate attribute (uv3.x).
            But now additional information about lighting for two scenarios must be stored. A texture coordinate can store up to four values,
            but we need at least 7 values (1 for AO + 6 for the two rgb intensities of the lighting scenarios). Another two values are
            added to regulate final occlusion and lighting intensity, which makes a total of 9 values.
        </p>

        <p>
            In order to fit 9 values into a 4-channel texture coordinate, some packing must be done. Lighting colors need high precision because lighting
            must allow values above one. I decided to use 10 bit color depth for lighting, with values ranging between 0 and 10.
            Therefore, each lighting scenario is stored in one channel of the uv3 (uv3.y and uv3.w). This leaves 2 bits unused, but it's not really a
            problem. Occlusion is still stored in uv3.x unpacked, and strength values are packed using 16-bit depth in uv3.z. Since both
            scenarios are stored in the same UV, it is possible to blend between them in realtime using a global uniform value:
        </p>

        <video src="VertexLighting/Videos/VertexLighting_Transitions.mp4" poster="VertexLighting/Videos/VertexLighting_Transitions_Poster.png"></video>

        <!--<div data-video='{
        "video" : "Articles/VertexLighting/Videos/VertexLighting_Transitions.mp4"
         , "poster" : "Articles/VertexLighting/Videos/VertexLighting_Transitions_Poster.png"
    }'></div>-->

        <p>
            This is the code used for packing vertex data in the CPU:
        </p>

        <pre><code data-lang="C#">
        static Vector4 EncodeOcclusionLighting(
        float occlusion, 
        Vector3 light, 
        Vector3 light2, 
        float occlusionStrength, 
        float lightingStrength)
        {
            Vector4 texcoord = Vector4.zero;
            texcoord.x = occlusion;

            light /= 10.0f;
            light2 /= 10.0f;

            light.x = Mathf.Clamp01(light.x);
            light.y = Mathf.Clamp01(light.y);
            light.z = Mathf.Clamp01(light.z);
            light2.x = Mathf.Clamp01(light2.x);
            light2.y = Mathf.Clamp01(light2.y);
            light2.z = Mathf.Clamp01(light2.z);

            texcoord.y = PackThreeFloats(light.x, light.y, light.z);
            texcoord.z = PackTwoFloats(occlusionStrength, lightingStrength);
            texcoord.w = PackThreeFloats(light2.x, light2.y, light2.z);

            return texcoord;
        }

        static float PackTwoFloats(float a, float b)
        {
            uint ai = (uint)(a * 65535);
            uint bi = (uint)(b * 65535);
            uint packed = (ai << 16) | bi;
            return IntToFloat.Convert(packed);
        }

        static float PackThreeFloats(float a, float b, float c)
        {
            uint ai = (uint)(a * 1023);
            uint bi = (uint)(b * 1023);
            uint ci = (uint)(c * 1023);
            uint packed = (ai << 20) | (bi << 10) | ci;
            return IntToFloat.Convert(packed);
        }

        [StructLayout(LayoutKind.Explicit)]
        struct IntToFloat
        {
            [FieldOffset(0)] private float f;
            [FieldOffset(0)] private uint ui;
            public static float Convert(uint value)
            {
                return new IntToFloat { ui = value }.f;
            }
        }
        </code></pre>

        

        <!--<div class="code" data-lang="C#" data-url="Articles/VertexLighting/Packing.cs"></div>-->

        <p>
            Then, in the vertex shader, the data in unpacked. Note that the uv must be unpacked in the vertex shader,
            it can't be passed to the fragment shader because it would be interpolated and the unpacked result would
            just be noise. These are the functions used:
        </p>

        <pre><code data-lang="hlsl">
        float4 _GlobalVertexOcclusionColor = 1;
        float _GlobalVertexOcclusionStrength = 1;
        float _GlobalVertexLightingStrength = 1;
        float _GlobalVertexLightingTransition = 0;

        void UnpackTwoFloats(float packed, 
            out float a, out float b)
        {
            uint packedInt = asuint(packed);
            a = float((packedInt >> 16) & 0xFFFF) / 65535.0;
            b = float(packedInt & 0xFFFF) / 65535.0;
        }

        void UnpackThreeFloats(float packed, 
            out float a, out float b, out float c)
        {
            uint packedInt = asuint(packed);
            a = float((packedInt >> 20) & 0x3FF) / 1023.0;
            b = float((packedInt >> 10) & 0x3FF) / 1023.0;
            c = float(packedInt & 0x3FF) / 1023.0;
        }

        void UnpackBakedVertexData_float(float4 uv, 
            out float3 ao, out float3 lighting, 
            out float aoStrength, out float lightingStrength)
        {
            ao = lerp(_GlobalVertexOcclusionColor.rgb, float3(1, 1, 1), uv.x);
            float lightR, lightG, lightB;
            float light2R, light2G, light2B;
            UnpackThreeFloats(uv.y, lightR, lightG, lightB);
            UnpackTwoFloats(uv.z, aoStrength, lightingStrength);
            UnpackThreeFloats(uv.w, light2R, light2G, light2B);
    
            float3 light1 = float3(lightR, lightG, lightB) * 10.0;
            float3 light2 = float3(light2R, light2G, light2B) * 10.0;

            lighting = lerp(light1, light2, _GlobalVertexLightingTransition);
            aoStrength *= _GlobalVertexOcclusionStrength;
            lightingStrength *= _GlobalVertexLightingStrength;

        }
        </code></pre>

        <!--<div class="code" data-lang="hlsl" data-url="Articles/VertexLighting/Unpacking.hlsl"></div>-->

        <p>
            The unpacked data looks like this:
        </p>

        <figure data-image='{"maximizable": true}'>
            <img src="VertexLighting/Images/VertexLighting_MilkBar_Debug.png" alt="Unpacked uv3" />
            <figcaption>Unpacked uv3</figcaption>
        </figure>

        <!--<div data-image='{
        "images": ["Articles/VertexLighting/Images/VertexLighting_MilkBar_Debug.png"]
        , "texts": ["Unpacked uv3"]
        , "maximizable": true
    }'></div>-->

        <h4>Performance</h4>

        <p>
            Once the algorithm was complete and we tested it on complex models, it terribly underperformed in terms of speed. What had to be executed in less than
            five seconds, took minutes or even hours if using indirect lighting.
        </p>

        <p>
            If we didn't address this issue, baking would be a pain during the entire development process. Not only that, but it would disincentivize the use of
            baked lights, reducing the overall quality of the presentation.
        </p>

        <p>
            Fortunately, this algorithm is highly parallelizable, so I created a compute shader and mirrored the entire algorithm. In the CPU implementation,
            Unity's collider components are used to raycast occlusion, shadows, and indirect lighting. Implementing that in a compute
            shader is feashible, but it would take a considerable amount of effort. Thankfully, raytracing shaders exist so I didn't
            have to implement mesh raycasting myself.
        </p>

        <p>
            Using raytracing and compute shaders improves performance dramatically. baking an entire environment is now just a matter of seconds,
            even with all the features enabled. Now, artists can iterate on lighting blazingly fast. To make it even quicker, I added a
            keyboard shortcut to preview results that doesn't save them persistenly and only bakes the current lighting scenario.
        </p>

        <p>
            You can see different timings in the following table. Notice how indirect lighting is expensive, and unreasonably slow
            when several lights are baked in CPU.
        </p>

        <table>
            <tr>
                <th>Scene</th>
                <th>Vertices</th>
                <th>Lights</th>
                <th class="columnSeparator"></th>
                <th>CPU Indirect Off</th>
                <th>GPU Indirect Off</th>
                <th>CPU Indirect On</th>
                <th>GPU Indirect On</th>
            </tr>
            <tr>
                <td>Bomb Shop</td>
                <td>10245</td>
                <td>1</td>
                <td class="columnSeparator"></td>
                <td class="columnBright">4.40s</td>
                <td>0.10s</td>
                <td class="columnBright">115.67s</td>
                <td>0.32s</td>
            </tr>
            <tr>
                <td>Curiosity Shop</td>
                <td>7631</td>
                <td>2</td>
                <td class="columnSeparator"></td>
                <td class="columnBright">4.72s</td>
                <td>0.29s</td>
                <td class="columnBright">187.73s</td>
                <td>0.47s</td>
            </tr>
            <tr>
                <td>Milk Bar</td>
                <td>23589</td>
                <td>24</td>
                <td class="columnSeparator"></td>
                <td class="columnBright">47.25s</td>
                <td>0.34s</td>
                <td class="columnBright">8057.14s</td>
                <td>2.18s</td>
            </tr>
        </table>


        <h3>Results</h3>

        <figure data-image='{"sliderValue":50, "maximizable": true}'>
            <img src="VertexLighting/Images/VertexLighting_BombShop_Unlit.png" alt="Unlit" />
            <img src="VertexLighting/Images/VertexLighting_BombShop_Lit.png" alt="Baked Lit" />
            <figcaption>Unlit vs Baked Lit</figcaption>
        </figure>

        <!--<div data-image='{
        "images": ["Articles/VertexLighting/Images/VertexLighting_BombShop_Unlit.png", "Articles/VertexLighting/Images/VertexLighting_BombShop_Lit.png"]
        , "texts": ["Unlit", "Baked Lit"]
        , "sliderValue": 50
        , "maximizable": true
    }'></div>-->

        <figure data-image='{"sliderValue":50, "maximizable": true}'>
            <img src="VertexLighting/Images/VertexLighting_CuriosityShop_Unlit.png" alt="Unlit" />
            <img src="VertexLighting/Images/VertexLighting_CuriosityShop_Lit.png" alt="Baked Lit" />
            <figcaption>Unlit vs Baked Lit</figcaption>
        </figure>

        <!--<div data-image='{
        "images": ["Articles/VertexLighting/Images/VertexLighting_CuriosityShop_Unlit.png", "Articles/VertexLighting/Images/VertexLighting_CuriosityShop_Lit.png"]
        , "texts": ["Unlit", "Baked Lit"]
        , "sliderValue": 50
        , "maximizable": true
    }'></div>-->

        <figure data-image='{"sliderValue":50, "maximizable": true}'>
            <img src="VertexLighting/Images/VertexLighting_MilkBar_Unlit_0.png" alt="Unlit" />
            <img src="VertexLighting/Images/VertexLighting_MilkBar_LitIndirect_0.png" alt="Baked Lit" />
            <figcaption>Unlit vs Baked Lit</figcaption>
        </figure>

        <!--<div data-image='{
        "images": ["Articles/VertexLighting/Images/VertexLighting_MilkBar_Unlit_0.png", "Articles/VertexLighting/Images/VertexLighting_MilkBar_LitIndirect_0.png"]
        , "texts": ["Unlit", "Baked Lit"]
        , "sliderValue": 50
        , "maximizable": true
    }'></div>-->

        <figure data-image='{"sliderValue":50, "maximizable": true}'>
            <img src="VertexLighting/Images/VertexLighting_MilkBar_Unlit_1.png" alt="Unlit" />
            <img src="VertexLighting/Images/VertexLighting_MilkBar_LitIndirect_1.png" alt="Baked Lit" />
            <figcaption>Unlit vs Baked Lit</figcaption>
        </figure>

        <!--<div data-image='{
        "images": ["Articles/VertexLighting/Images/VertexLighting_MilkBar_Unlit_1.png", "Articles/VertexLighting/Images/VertexLighting_MilkBar_LitIndirect_1.png"]
        , "texts": ["Unlit", "Baked Lit"]
        , "sliderValue": 50
        , "maximizable": true
    }'></div>-->

        <figure data-image='{"sliderValue":50, "maximizable": true}'>
            <img src="VertexLighting/Images/VertexLighting_MilkBar_Unlit_2.png" alt="Unlit" />
            <img src="VertexLighting/Images/VertexLighting_MilkBar_LitIndirect_2.png" alt="Baked Lit" />
            <figcaption>Unlit vs Baked Lit</figcaption>
        </figure>

        <!--<div data-image='{
        "images": ["Articles/VertexLighting/Images/VertexLighting_MilkBar_Unlit_2.png", "Articles/VertexLighting/Images/VertexLighting_MilkBar_LitIndirect_2.png"]
        , "texts": ["Unlit", "Baked Lit"]
        , "sliderValue": 50
        , "maximizable": true
    }'></div>-->

        <figure data-image='{"sliderValue":50, "maximizable": true}'>
            <img src="VertexLighting/Images/VertexLighting_MilkBar_Unlit_3.png" alt="Unlit" />
            <img src="VertexLighting/Images/VertexLighting_MilkBar_LitIndirect_3.png" alt="Baked Lit" />
            <figcaption>Unlit vs Baked Lit</figcaption>
        </figure>

        <!--<div data-image='{
        "images": ["Articles/VertexLighting/Images/VertexLighting_MilkBar_Unlit_3.png", "Articles/VertexLighting/Images/VertexLighting_MilkBar_LitIndirect_3.png"]
        , "texts": ["Unlit", "Baked Lit"]
        , "sliderValue": 50
        , "maximizable": true
    }'></div>-->

        <h3>Conclusion</h3>

        <p>
            Baking lighting information per-vertex results in a shading style with a lot of
            personality that is reminiscent of many retro games. After using this lighting system
            in the actual environments of the game we're working on, which I still can't show, we're
            finally seeing the artistic vision come to life in realtime.
        </p>

        <p>
            It is clear that interpolating vertex attributes won't look as realistic as
            per-pixel lighting or lightmaps, but that is exactly what gives this lighting technique its own look. It's physically based, meaning
            that it is realistic, but is constrained by limitations often seen in older platforms. Not only this is what the art team was looking for, but
            it can be computed very fast on current hardware, and has almost zero cost at runtime. It's yet to be seen how it will evolve during
            development, but it's a great starting point.
        </p>

        <h3>Going forward</h3>

        <p>
            This lighting system is already pretty much feature complete, but there some aspects of it that could be further developed:
        </p>

        <ul>
            <li>
                <b>Specular highlights</b>: It is difficult to bake specular highlights because they depend on the viewer's perspective.
                However, many retro games faked specular highlights in different ways. Since the viewer's perspective does not change a lot
                in our game, it could be possible to just define a fixed position or direction to calculate specular hightlights and leave them
                baked.
            </li>
            <li>
                <b>Different properties per object</b>: Right now all objects are shaded uniformly, but if could be benefitial to take into account
                certain physical properties of the materials, such as metallic, smoothness, etc.
            </li>
            <li>
                <b>Lighting scenarios limitations</b>: Only two baking sets can actually be used, but it might be necessary to use more in the future. If blending
                can occur between any given pair of scenarios, packing will have to be done differently or an extra texture coordinate would have to be used.
                Otherwise, it might be possible to bake other scenarios to a different buffer and swap the uv data based on the lighting scenario as needed.
            </li>

        </ul>
    </main>
    <script src="/main.js"></script>
</body>

