<h1>Vertex Ambient Occlusion</h1>
<h2>
    March 10th, 2025 <br />
    Unreleased Project
</h2>

<h3>Motivation</h3>

<p>
    Recently I found myself enjoying the world of Termina while playing <i>The Legend of Zelda: Majora's Mask 3D</i>. Each time I entered
    a house in Clock Town I thought the lighting looked amazing for a 3DS game. Per vertex lighting was used in many 3DS games to minimize
    shading cost, but that's not all that is going on in this game. Indirect lighting is baked into vertex attributes to speed up performance
    while still getting a high quality approximation.
</p>

<div data-image='{
    "images": ["Articles/VertexAO/Images/VertexAO_029_BombShop_Base.png", "Articles/VertexAO/Images/VertexAO_031_BombShop_Lit.png"]
    , "texts": ["Unlit", "AO + Light"]
    , "sliderValue": 50
    , "maximizable": true
}'></div>

<p>
    I decided to split lighting calculations into two major factors:
</p>

<ul>
    <li>
        Realtime per vertex lighting: Since I'm using the Unity Engine, this is lighting technique is already available.
    </li>
    <li>
        Baked per vertex ambient occlusion: Instead of baking indirect lighting from actual light sources, I decided to calculate average occlusion
        surrounding the vertex, so that the result could be valid in any lighting scenario. This is similar to how SSAO works. Since this is not
        implemented in Unity, it's up to me to come up with an algorithm to compute occlusion.
    </li>
</ul>

<h3>Implementation</h3>

<p>The first idea that comes to mind seems very straightfoward:</p>

<ul>
    <li>1: Iterate all vertices.</li>
    <li>2: Raycast in many directions in the hemisphere pointing towards the vertex normal.</li>
    <li>3: Average occlusion data based on hit count and distance between the vertex and the occluders.</li>
</ul>

<div data-image='{
    "images": ["Articles/VertexAO/Images/VertexAO_Explanation2.png"]
    , "maximizable": false
}'></div>

<p>I'm going to use a simple mesh to debug the results using the mentioned algorithm:</p>

<div data-image='{
    "images": ["Articles/VertexAO/Images/VertexAO_001_NaiveApproach.png"]
    , "maximizable": false
}'></div>

<p>
    There is a clear problem with this approach: At corners, like a vertex that is at the end of a floor connecting to a vertical wall, the rays
    origin are coplanar with the wall and floor triangles, possibly causing false negatives when raycasting. We can alleviate this problem offsetting
    the rays origin, but where to?
</p>

<p>As I said, the raycasting origin is coplanar with its own triangle and potentially other triangles. We need to apply two different offsets:</p>

<ul>
    <li>Normal offset: Easy enough, by displacing the rays origin a bit along the normal, it stops being coplanar with its own triangle.</li>
    <li>
        Tangent offset: This is where things get a bit more complicated. Calculating a tangent to the vector is straightforward, but if we
        just moved towards any vector perpendicular to the normal, we could potentially end up outside the original triangle!
    </li>
</ul>

<p>
    What we need is to find a tangent direction along the triangle, and to make sure that the rays origin does not end up outside the original
    triangle while doing so.
</p>

<ul>
    <li>1: Calculate the bisector vector that splits the triangle in two triangles with equal angles at each side.</li>
    <li>2: Calculate the intersection between the bisector vector and the line defined by the other two vertices of the current vertex triangle.</li>
    <li>
        3: Move along the bisector vector a certain distance. If it exceeds the calculated intersection, use the intersection to prevent stepping out
        of the triangle.
    </li>
</ul>

<div data-image='{
    "images": ["Articles/VertexAO/Images/VertexAO_Explanation0.png"]
    , "maximizable": false
}'></div>

<p>
    This allows us to effectively raycast from an origin with a normal and tangent offset. However, a vertex may belong to more than one triangle, so I came up with a
    way to use all those triangles to calculate occlusion:
</p>

<ul>
    <li>1: Gather all the triangles in advance and store the the angle for each of those triangles for the vertex corner.</li>
    <li>2: Calculate the total angle by summing each triangle's angle and weight each triangle's contribution based on the angle ratio.</li>
    <li>3: Distribute the ray count around each triangle based on their weight so that triangles with a bigger angle do more raycasts.</li>
</ul>

<div data-image='{
    "images": ["Articles/VertexAO/Images/VertexAO_Explanation1.png"]
    , "maximizable": false
}'></div>

<p>Let's check the previous example again with the updated algorithm:</p>

<div data-image='{
    "images": ["Articles/VertexAO/Images/VertexAO_002_SampleNeighbourhood.png"]
    , "maximizable": false
}'></div>

<p>Let's also check how the algorithm behaves with rounded shapes:</p>

<div data-image='{
    "images": ["Articles/VertexAO/Images/VertexAO_003_RoundedShapes.png"]
    , "maximizable": false
}'></div>

<p>
    There are many factors related to mesh topology that can affect the final look of this ambient
    occlusion implementation. A lot of care must be put into crafting the meshes for them to
    be baked in this manner. These are some of the options I added to help artists achieve a
    good result with this tool:
</p>

<ul>
    <li>
        Look:
        <ul>
            <li>Range: the radius of the hemisphere.</li>
            <li>Curve: since the result of the AO is linear, this curve can be used to modify that look and make it smoother.</li>
        </ul>
    </li>
    <li>
        Raycasting:
        <ul>
            <li>
                Max angle: the max angle of the hemisphere is 90 degrees by default, which could capture non-intended occlusion. This variable can be used
                to alleviate that problem is desired.
            </li>
            <li>Vertex and normal Offset: how far from the vertex the rays should originate.</li>
            <li>Double sided: allows to configure the behaviour of raycasting when colliding against triangles that are not facing the vertex.</li>
        </ul>
    </li>
    <li>
        Merging:
        <ul>
            <li>Smooth normals: allows the user to preprocess the mesh before calculating AO to average the normals of nearby vertices.</li>
            <li>Merge results: allows the user to postprocess the mesh after calculating AO to average the occlusion values of nearby vertices.</li>
        </ul>
    </li>
</ul>

<p>
    Finally, these results must be saved. I chose to store the occlusion values in a byte array (8-bit depth for occlusion). The array also contains
    information about meshes names and vertex count so that occlusion values can be invalidated if the model changed significantly. Additionally,
    there are different places where we might want to store the byte array:
</p>

<ul>
    <li>
        Per model: The occlusion values are stored in a binary file next to the original mode. Each time the model is reimported the occlusion values are reapplied.
        If the model is deleted, the occlusion file and its meta file are automatically removed from the project.
    </li>
    <li>
        Per instance: The occlusion values are serialized in the component and reapplied on an instanced mesh when the game object is initialized for the first time.
    </li>
</ul>

<h3>Results</h3>

<p>With this working as intended, let's move on to more complicated meshes, such as characters.</p>

<div data-image='{
    "images": ["Articles/VertexAO/Images/VertexAO_CharactersAO.png"]
    , "maximizable": true
    , "texts" : ["Character Occlusion"]
}'></div>

<div data-image='{
    "images": ["Articles/VertexAO/Images/VertexAO_005_DekuLink_Base.png", "Articles/VertexAO/Images/VertexAO_006_DekuLink_Final.png"]
    , "texts": ["AO Off", "AO On"]
    , "sliderValue": 50
    , "maximizable": true
}'></div>

<div data-image='{
    "images": ["Articles/VertexAO/Images/VertexAO_012_Link_Base.png", "Articles/VertexAO/Images/VertexAO_013_Link_Final.png"]
    , "texts": ["AO Off", "AO On"]
    , "sliderValue": 50
    , "maximizable": true
}'></div>

<p>
    Alright, so characters can have proper occlusion, but what about environments? This is an even more important part because
    character AO can easily be painted by an artist but painting an entire scene's ambient occlusion is much more complex. Thus, this
    is where this algorithm can be better utilized. Take into account that there are no lights in the following pictures, just ambient occlusion, so
    they might seem a bit dark but it is to be expected.
</p>

<div data-image='{
    "images": ["Articles/VertexAO/Images/VertexAO_014_MilkBar_AO.png"]
    , "maximizable": true
    , "texts" : ["Environment Occlusion 1"]
}'></div>

<div data-image='{
    "images": ["Articles/VertexAO/Images/VertexAO_015_MilkBar_Base.png", "Articles/VertexAO/Images/VertexAO_016_MilkBar_Final.png"]
    , "texts": ["AO Off", "AO On"]
    , "sliderValue": 50
    , "maximizable": true
}'></div>

<div data-image='{
    "images": ["Articles/VertexAO/Images/VertexAO_025_CuriosityShop_AO.png"]
    , "maximizable": true
    , "texts" : ["Environment Occlusion 2"]
}'></div>

<div data-image='{
    "images": ["Articles/VertexAO/Images/VertexAO_026_CuriosityShop_Base.png", "Articles/VertexAO/Images/VertexAO_027_CuriosityShop_Final.png"]
    , "texts": ["AO Off", "AO On"]
    , "sliderValue": 50
    , "maximizable": true
}'></div>

<div data-image='{
    "images": ["Articles/VertexAO/Images/VertexAO_028_BombShop_AO.png"]
    , "maximizable": true
    , "texts" : ["Environment Occlusion 3"]
}'></div>

<div data-image='{
    "images": ["Articles/VertexAO/Images/VertexAO_029_BombShop_Base.png", "Articles/VertexAO/Images/VertexAO_030_BombShop_Final.png"]
    , "texts": ["AO Off", "AO On"]
    , "sliderValue": 50
    , "maximizable": true
}'></div>

<h3>Conclusion</h3>

<p>
    Baking ambient occlusion as vertex data is an elegant and simple solution to a complex problem. Calculating proper ambient occlusion
    in realtime remains a major undertaking to this day. The best results can be achieved using raytracing, but it is very expensive. Another option is SSAO but it
    becomes unstable if used with a large radius. Lightmaps could be considered, but they require modifying shaders to support them and take up a significant amount of memory.
</p>

<p>
    At the end of the day, nothing beats storing data as vertex attributes in terms of performance, especially if you combine existing vertex color with occlusion values.
    If you are going for a retro look or have a tight technical budget, this might be your best bet.
</p>

<p>
    However, as I mentioned earlier, meshes need to be designed with a relatively uniform triangle density while minimizing clipping. If you're already deep into
    development and your models weren't created with this in mind, adapting them could require a lot of time and effort. Additionally, since this is not a realtime
    solution, you will have to add contact shadows to dynamic objects using a different technique, such as blob shadows.
</p>

<h3>Going forward</h3>

<p>
  We could actually go a step forward and bake indirect and even direct lighting from static light sources into vertex data. As it's usually the case with lightmaps, most if not all lighting information would be baked and only dynamic objects would require realtime lighting calculations.
</p>

<p>
  In the AO solution presented in this article, occlusion is not calculated by actually simulating the bounces of light rays, so that could be another potential area of research.
  </p>