<h1>Vertex Ambient Occlusion</h1>
<h2>
    March 10th, 2025 <br />
    Unreleased Project
</h2>

<h3>Motivation</h3>

<h3>Implementation</h3>

<p>At first, the approach seems rather simple:</p>

<ul>
    <li>1: Iterate all vertices.</li>
    <li>2: Raycast in many directions in the hemisphere pointing towards the vertex normal.</li>
    <li>3: Average occlusion data based on hit count.</li>
</ul>

<p>I'm going to use a simple mesh to debug the results using the mentioned algorithm:</p>

<div data-image='{
    "images": ["Articles/VertexAO/Images/VertexAO_001_NaiveApproach.png"]
    , "maximizable": false
    , "texts" : ["Naive approach"]
}'></div>

<p>
    There is a clear problem with this approach: At corners, like a vertex that is at the end of a floor connecting to a vertical wall, the rays
    origin are coplanar with the wall and floor triangles, possibly causing false negatives when raycasting. We can alleviate this problem offsetting
    the rays origin, but where to?
</p>

<p>As I said, the raycasting origin is coplanar with its own triangle and potentially other triangles. We need to apply two different offsets:</p>

<ul>
    <li>Normal offset: Easy enough, by displacing the rays origin a bit along the normal, it stops being coplanar with its own triangle.</li>
    <li>
        Tangent offset: This is where things get a bit more complicated. Calculating a tangent to the vector is straightforward, but if we
        just moved towards any vector perpendicular to the normal, we could potentially end up outside the original triangle!
    </li>
</ul>

<p>
    What we need is to find a tangent direction along the triangle, and to make sure that the rays origin does not end up outside the original
    triangle while doing so.
</p>

<ul>
    <li>1: Calculate the bisector vector that splits the triangle in two triangles with equal angles at each side.</li>
    <li>2: Calculate the intersection between the bisector vector and the line defined by the other two vertices of the current vertex triangle.</li>
    <li>
        3: Move along the bisector vector a certain distance. If it exceeds the calculated intersection, use the intersection to prevent stepping out
        of the triangle.
    </li>
</ul>

<div data-image='{
    "images": ["Articles/VertexAO/Images/VertexAO_Explanation0.png"]
    , "maximizable": false
    , "texts" : ["Tangent offset"]
}'></div>

<p>
    This allows us to effectively raycast from an origin with a normal and tangent offset. However, a vertex may belong to more than one triangle, so I came up with a
    way to use all those triangles to calculate occlusion:
</p>

<ul>
    <li>1: Gather all the triangles in advance and store the the angle for each of those triangles for the vertex corner.</li>
    <li>2: Calculate the total angle by summing each triangle's angle and weight each triangle's contribution based on the angle ratio.</li>
    <li>3: Distribute the ray count around each triangle based on their weight so that triangles with a bigger angle do more raycasts.</li>
</ul>

<div data-image='{
    "images": ["Articles/VertexAO/Images/VertexAO_Explanation1.png"]
    , "maximizable": false
    , "texts" : ["Sample distribution"]
}'></div>

<p>Let's check the previous example again with the updated algorithm:</p>

<div data-image='{
    "images": ["Articles/VertexAO/Images/VertexAO_002_SampleNeighbourhood.png"]
    , "maximizable": false
    , "texts" : ["Neighbouring triangles approach"]
}'></div>

<p>Let's also check how the algorithm behaves with rounded shapes:</p>

<div data-image='{
    "images": ["Articles/VertexAO/Images/VertexAO_003_RoundedShapes.png"]
    , "maximizable": false
    , "texts" : ["Rounded shapes"]
}'></div>



<h3>Results</h3>

<p>With this working as intended, let's move on to more complicated meshes, such as characters.</p>

<div data-image='{
    "images": ["Articles/VertexAO/Images/VertexAO_CharactersAO.png"]
    , "maximizable": true
    , "texts" : ["Character Occlusion"]
}'></div>

<div data-image='{
    "images": ["Articles/VertexAO/Images/VertexAO_005_DekuLink_Base.png", "Articles/VertexAO/Images/VertexAO_006_DekuLink_Final.png"]
    , "texts": ["AO Off", "AO On"]
    , "sliderValue": 50
    , "maximizable": true
}'></div>

<div data-image='{
    "images": ["Articles/VertexAO/Images/VertexAO_012_Link_Base.png", "Articles/VertexAO/Images/VertexAO_013_Link_Final.png"]
    , "texts": ["AO Off", "AO On"]
    , "sliderValue": 50
    , "maximizable": true
}'></div>

<p>
    Alright, so characters can have proper occlusion, but what about environments? This is an even more important part because
    character AO can easily be painted by an artist but painting an entire scene's ambient occlusion is much more complex. Thus, this
    is where this algorithm can better utilized.
</p>

<div data-image='{
    "images": ["Articles/VertexAO/Images/VertexAO_014_MilkBar_AO.png"]
    , "maximizable": true
    , "texts" : ["Environment Occlusion 1"]
}'></div>

<div data-image='{
    "images": ["Articles/VertexAO/Images/VertexAO_015_MilkBar_Base.png", "Articles/VertexAO/Images/VertexAO_016_MilkBar_Final.png"]
    , "texts": ["AO Off", "AO On"]
    , "sliderValue": 50
    , "maximizable": true
}'></div>

<div data-image='{
    "images": ["Articles/VertexAO/Images/VertexAO_018_CuriosityShop_AO.png"]
    , "maximizable": true
    , "texts" : ["Environment Occlusion 2"]
}'></div>

<div data-image='{
    "images": ["Articles/VertexAO/Images/VertexAO_019_CuriosityShop_Base.png", "Articles/VertexAO/Images/VertexAO_021_CuriosityShop_Final.png"]
    , "texts": ["AO Off", "AO On"]
    , "sliderValue": 50
    , "maximizable": true
}'></div>

<h3>Conclusion</h3>

<h3>Going forward</h3>